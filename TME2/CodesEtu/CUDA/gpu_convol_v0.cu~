/**
 * Programmation GPU 
 * Université Pierre et Marie Curie
 * Calcul de convolution sur une image.
 */

/**
 * V0
 *
 */

#include <cuda.h>
#include <stdio.h>

extern "C" double my_gettimeofday();

/** 
 * Controle des erreurs CUDA et debugging. 
 */

#ifdef CUDA_DEBUG
#define CUDA_SYNC_ERROR() {						\
    cudaError_t sync_error;						\
    cudaDeviceSynchronize();						\
    sync_error = cudaGetLastError();					\
    if(sync_error != cudaSuccess) {					\
      fprintf(stderr, "[CUDA SYNC ERROR at %s:%d -> %s]\n",		\
	      __FILE__ , __LINE__, cudaGetErrorString(sync_error));	\
      exit(EXIT_FAILURE);						\
    }									\
  }
#else /* #ifdef CUDA_DEBUG */
#define CUDA_SYNC_ERROR()
#endif /* #ifdef CUDA_DEBUG */

#define CUDA_ERROR(cuda_call) {					\
    cudaError_t error = cuda_call;				\
    if(error != cudaSuccess){					\
      fprintf(stderr, "[CUDA ERROR at %s:%d -> %s]\n",		\
	      __FILE__ , __LINE__, cudaGetErrorString(error));	\
      exit(EXIT_FAILURE);					\
    }								\
    CUDA_SYNC_ERROR();						\
  }



/**
 * Retourne le quotient entier superieur ou egal a "a/b". 
 * D'apres : CUDA SDK 4.1 
 */

static int iDivUp(int a, int b){
  return ((a % b != 0) ? (a / b + 1) : (a / b));
}


__global__ void convolKernel(float *buf_src, float *buf_tgt, int nbl, int nbc)
{
	unsigned int j = blockDim.x * blockIdx.x + threadIdx.x;
  	unsigned int i = blockDim.y * blockIdx.y + threadIdx.y;

	float numerateur, denominateur;
  	float poids_central; 
  
	
       /*** filtre moyenneur CONVOL_MOYENNE2 (filtre moyenneur avec 
       * un poid central plus fort):
       * Rq: pour les bords, moyenne avec uniquement les cases presentes */
      denominateur = 0.0f; 
      numerateur = 0.0f;
      if (i<nbl-1){
	numerateur += buf_src[(i+1)*nbc+j]; ++denominateur;
	if (j>0){     numerateur += buf_src[(i+1)*nbc+j-1]; ++denominateur; }
	if (j<nbc-1){ numerateur += buf_src[(i+1)*nbc+j+1]; ++denominateur; }
      }
      if (j>0){     numerateur += buf_src[(i)*nbc+j-1]; ++denominateur; }
      if (j<nbc-1){ numerateur += buf_src[(i)*nbc+j+1]; ++denominateur; } 
      if (i>0){
	numerateur +=  buf_src[(i-1)*nbc+j]; ++denominateur; 
	if (j>0){     numerateur += buf_src[(i-1)*nbc+j-1]; ++denominateur; }
	if (j<nbc-1){ numerateur += buf_src[(i-1)*nbc+j+1]; ++denominateur; }
      }
      poids_central = denominateur*0.5f; /* poids centrale = 50% autres poids */
      numerateur   += poids_central*buf_src[(i)*nbc+j];
      denominateur += poids_central;

      buf_tgt[i*nbc+j] = numerateur/denominateur;	
}

/**
 * Effectue 'nbiter' convolutions sur GPU et retourne
 * le pointeur vers le buffer contenant la derniere convolution. 
 */

extern "C"
float *gpu_multiples_convolutions(float buf[], 
				  float buf_aux[], 
				  int nbl, 
				  int nbc,
				  int nbiter, 
				  int nbThreadsParBloc){
  
  /*** TODO ***/;
  float *d_buf, *d_buf_aux;
  int allocSize = nbc * nbc * sizeof(float);

  cudaMalloc((void**) &d_buf, allocSize);
  cudaMalloc((void**) &d_buf_aux, allocSize);

  cudaMemcpy(d_buf, buf, allocSize, cudaMemcpyHostToDevice);
  cudaMemcpy(d_buf_aux, buf_aux, allocSize, cudaMemcpyHostToDevice);

  dim3 threads_par_bloc(16,16);
  dim3 gridSize(ceil(nbc/(float)16), ceil(nbl/(float)16));

  int i;
  for (i=0; i<nbiter; i++){
      convolKernel<<<gridSize, threads_par_bloc>>>(d_buf, d_buf_aux, nbl, nbc);
      /*On swap les buffers*/
      cudaMemcpy(d_buf, d_buf_aux, allocSize, cudaMemcpyDeviceToDevice);
  }
  
}
